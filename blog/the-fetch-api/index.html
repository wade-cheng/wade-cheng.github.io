<!DOCTYPE html>

<html lang="en">
    <head>
        <!-- dark mode switcher js -->
        <!-- <script>
            const THEMES = {
                dark: {
                    "--bg": "#20384B",
                    "--text": "#E1F2FF",
                    "--code-bg": "#E1F2FF",
                    "--code-text": "#20384B",
                },
                light: {
                    "--bg": "white",
                    "--text": "black",
                    "--code-bg": "#363636",
                    "--code-text": "#E3E3E3",
                },
            };
            function checkDarkmode() {
                //console.log("got here");
                let root = document.documentElement.style;

                Object.entries(THEMES[localStorage.getItem("theme")]).forEach(
                    (propval) => root.setProperty(propval[0], propval[1]),
                );
            }

            checkDarkmode();
        </script> -->

        <!-- fonts -->
        <link rel="stylesheet" href="/assets/eb-garamond/eb-garamond.css" />
        <!-- <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <link
            href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400..800;1,400..800&display=swap"
            rel="stylesheet"
        /> -->
        <!-- these fonts look alright too: <link
            href="https://fonts.googleapis.com/css2?family=Libertinus+Serif:ital,wght@0,400;0,700;1,400;1,700&display=swap"
            rel="stylesheet"
        />
        <link
        href="https://fonts.googleapis.com/css2?family=Vollkorn+SC:wght@400;600;700;900&family=Vollkorn:ital,wght@0,400..900;1,400..900&display=swap"
        rel="stylesheet"
        />
        -->

        <!-- standard metadata -->
        <meta charset="utf-8" />
        <title>wade's blog :: The Fetch API </title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <!-- https://css-tricks.com/essential-meta-tags-social-media/ -->
        <link href="/style.css" rel="stylesheet" type="text/css" />

        <!-- favicon stuff https://realfavicongenerator.net -->
        <link
            rel="icon"
            type="image/png"
            href="/favicon/favicon-96x96.png"
            sizes="96x96"
        />
        <link rel="icon" type="image/svg+xml" href="/favicon/favicon.svg" />
        <link rel="shortcut icon" href="/favicon/favicon.ico" />
        <link
            rel="apple-touch-icon"
            sizes="180x180"
            href="/favicon/apple-touch-icon.png"
        />
        <meta name="apple-mobile-web-app-title" content="wade's site" />
        <link rel="manifest" href="/favicon/site.webmanifest" />

        <!-- prefetch neko js -->
        <link rel="prefetch" href="https://webneko.net/n20171213.js" />

        <!-- custom head matter -->
        
<style>
    main p:first-of-type::first-line {
        font-variant: small-caps;
        font-feature-settings: "smcp";
    }
</style>

    </head>

    <body>
        <div id="site-container">
            <nav>
                <a href="/">home</a>
                <a href="/blog/">blog</a>
                <a href="/garden/">garden</a>
                <!-- <img src="/assets/nighttime.png" alt="" /> -->
            </nav>

            <header>
                <h1>The Fetch API</h1>

                
<div class="date">
    <time datetime="2025-10-27">October 27, 2025</time>
    <!--  -->
    <!--  -->
    
    <!--  -->
</div>

            </header>

            <main>
                

<!--  -->

<p>
    Javascript can pull data from remote servers by using something called the
    <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API"
        >Fetch API</a
    >. This has a couple names and concepts associated to it, like fetching, GET
    requests, or REST APIs. The scope of this blog post will be to
</p>

<ul class="tight">
    <li>develop a simple example for how you can use it</li>
    <li>to fetch a binary file</li>
    <li>as part of a web application.</li>
</ul>

<p>I’ll start with an empty folder to give us a clean workspace.</p>

<pre><code>~/fetch-example $ ls --all
. ..
</code></pre>

<p>
    First, we need some binary data. I’ll choose some random numbers (that fit
    in the range of an unsigned byte), and we can later confirm we’ve
    successfully fetched the file by looking for those numbers. I’ll use python
    to write the numbers to a file named <code>bin</code>, and double check it
    worked with <code>od</code>.
</p>

<pre><code>~/fetch-example $ python -c ‘open(“bin”, “wb”).write(bytearray([24, 100, 3, 1]))’
~/fetch-example $ od -td1 bin
0000000   24  100    3    1
0000004
</code></pre>

<p>
    Now, we need our “web application.” Let’s just have a single button, and
    when it’s pressed, fetch <code>bin</code> and console-log its contents. I’m
    putting this HTML code into <code>~/fetch-example/index.html</code>:
</p>

<pre><code>&lt;script&gt;
    async function log_bin() {
        const response = await fetch(‘bin’);
        const asbytes = await response.bytes(); 
        console.log(asbytes);
    }
&lt;/script&gt;

&lt;button onclick="log_bin()" /&gt;
</code></pre>

<p>Let’s break down what this is doing.</p>

<p>
    We have a function <code>log_bin</code> to log the binary file. It starts to
    fetch the file <code>bin</code>, and awaits its completion. Then, we save
    that response as bytes, awaiting here as well. Since those
    <code>await</code>s are
    <a
        href="https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Async_JS/Introducing"
        >async code</a
    >, the function containing them (<code>log_bin</code>) must be marked
    <code>async</code> as well. Finally, we log the byte representation. The
    button just calls this function.
</p>

<p>
    This is our final code! Changing <code>‘bin’</code> will let us fetch any
    data exposed through REST APIs or other HTTP GET calls. But to be able to
    test this locally, we need to pretend to be such a server. I prefer to spin
    up my local servers with python:
</p>

<pre><code>~/fetch-example $ python -m http.server
Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...
</code></pre>

<p>
    Now, visiting the link
    <a href="http://0.0.0.0:8000/">http://0.0.0.0:8000/</a> and clicking on the
    button logs the numbers from the start of the blog post. It works!
</p>

<img
    src="./output.png"
    alt="a screenshot of the button and a panel showing the output of the console log, which matches our chosen numbers from the start of the blog post"
/>

<h2 id="why-is-this-helpful"><a href="#why-is-this-helpful">why is this helpful?</a></h2>

<p>
    I chose the specific scope of this article because I’m working on a project
    that plans to roughly follow the above workflow. We control both the client
    and the server. Some data structure is serialized into binary, and is saved
    on the server. The client requests it from the server, deserializes it, and
    uses it to do business logic.
</p>


<p>
    <small><a href="/blog/">back to blog</a></small>
</p>

            </main>
        </div>
    </body>
</html>
